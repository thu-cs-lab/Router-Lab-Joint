# 计算机网络原理与计算机组成原理联合实验

最后更新：2020/05/01 14:20

## 版权声明

本项目为清华大学 2019-2020 年秋季学期计算机系《计算机网络原理》课程实验。
**未经作者授权，禁止用作任何其他用途，包括且不限于在其他课程或者其他学校中使用。**
作者保留一切追究侵权责任的权利。

## 实验要求

本联合实验要求在 ThinRouter 平台上实现一个 CPU + 路由器，路由器要求支持 RIP 协议和转发。

## 实验平台

ThinRouter 的样例工程在 [z4yx/thinpad_top#thinrouter.1](https://github.com/z4yx/thinpad_top/branches/thinrouter.1) ，克隆后就可以得到一个样例工程，引脚约束和基本的 testbench 已经提供好，KSZ 8795 芯片也会通过 SPI 协议自动配置。

## 实验指导

### 第一阶段：学习 AXI-Stream 协议、 RGMII 接口和基本的网络知识

#### 学习 AXI-Stream 协议

在本次实验中，我们已经把以太网 MAC 配置好，以太网帧的内容会通过 AXI-Stream 协议与其余逻辑进行交互。通过在 Vivado 中运行 testbench，可以找到接受到的以太网帧对应在 AXI-Stream 上的波形，把它和 testbench 中编写的以太网帧进行比较。

回答以下问题：

1. AXI-Stream 什么情况下传输一拍的数据（Data Beat）？
2. 握手是通过哪些信号完成的，握手的信号之间有什么依赖关系？
3. AXI-Stream 的 tuser 信号在这里可能代表什么意义？

#### 学习 RGMII 接口

实际在 FPGA 芯片 和以太网 PHY 芯片之间通信的是 RGMII 接口，请观察仿真中 RGMII 的波形，和上面 AXI-Stream 的进行比较，应该可以找到一些相同点和不同点。

回答以下问题：

1. RGMII 的频率是多少，数据和时钟是什么关系？
2. RGMII 和 AXI-Stream 的数据上长度和内容差异在哪里？
3. RGMII 中的 RX_CTL 信号代表什么意义？

#### 学习基础的网络知识

了解 IP 和 ARP 协议的基本功能和转发的概念，理解 KSZ8795 的 VLAN 配置，然后自己用 Linux 系统搭建一个网络，用 Linux 自带的转发功能，学会用 tcpdump 和 Wireshark 进行抓包分析。

了解转发的概念以后，可以基于 HAL 编写一个固定转发方式的路由器，比如只有 A B C三个结点，B 只处理 A 发给 C 和 C 发给 A的，检验 ping 是否成功。

阅读 testbench 中提供的样例以太网帧，估计一下路由器应该做出如何的反应。

回答以下问题：

1. VLAN 是做什么的，为什么需要 VLAN？
2. KSZ8795 作用是什么？
3. 需要转发 ARP 吗？
4. 什么样的 IP 需要转发，转发的依据是什么？
5. 转发 IP 的时候需要修改哪些字段？
6. 如何知道转发后新的 VLAN Tag 和目标 MAC 地址？

#### 尝试在仿真中实现 Loopback

Loopback 就是环回的意思，在 testbench 中，仿真代码会向 RGMII 不断发以太网帧，你要做的就是原样地发回去。你需要理解 AXI-Stream 接口的使用方式，主要是信号的握手和数据的传输过程。建议用一个单独的时钟域编写你的环回逻辑，通过一个异步 FIFO 把 MAC 的 125M 和单独的时钟隔开，这样你的逻辑有更多的时序自由度。

如果 Loopback 实现正确，你应该可以在仿真中看到 TX 的 RGMII 上有波形，并且它的内容和 RX 的内容是一样的。进一步，你可以尝试修改测试的以太网帧的内容，让它接受到不同长度的内容，并观察在 FCS 正确与错误时的表现。遇到问题时，可以在仿真中看 IP 的 Statistics Vector，然后查询文档。

如果在实现上遇到了困难，可以打开 IP 的 Example Design，里面有一个 Loopback 的实现，但比较复杂，不容易理解。并且，可以结合 RGMII 协议尝试理解一下 testbench 的实现方式，在后续编写各个模块的过程中也需要编写大量的测试。

回答以下问题：

1. IP 在校验 FCS 之后做了哪些事情，在 TX 的时候又对 FCS 做了什么？
2. 样例工程中对 IP 进行了哪些配置？
3. 如何处理 AXI-Stream 在 TX 时候 tready 不连续为高的情况？
4. testbench 为了生成一个 RGMII 信号，做了哪些事情？

#### 尝试在板子上实现 Loopback

基于上一步的成果，编写一段小的逻辑，实现目的 MAC 地址和源 MAC 地址的翻转，然后先在仿真中测试通过。仿真没问题后，再把代码生成 bitstream 到板子上，生成过程中一定注意 Critical Warning 和 Timing failed 信息，必须要重视并且进行修复，这一点是贯穿整个实验的，需要牢记。完成后把设备连到网口上，用 Wireshark 抓包，然后观察，如果出现一个包出现两次，只有 MAC 地址交换了的情况，说明实现正确，并且能正常运行。

如果在板子上工作不正常，请了解 ILA 的使用方式，从 AXI-Stream 的 RX 开始检查是否收到正确的以太网帧，然后按照数据流的顺序一路查到 AXI-Stream 的 TX。这个过程可能会很麻烦，但一定要耐心学会硬件调试的方法，如果有 Critical Warning 必须要注意，并且仿真中不应该出现带 X 和 Z 的有用的信号。

回答以下问题：

1. Vivado 提供的不同仿真模式有什么区别？
2. 如何查看 Timing 信息？
3. 如果出现 WNS 为负数，应该做哪些事情？
4. 仿真中的 X 和 Z 都是代码中怎么写出来的？

### 第二阶段：网络子模块设计

#### 实现转发表

上面提到过 IP 转发，转发的依据就是查转发表，转发表采用的是最长前缀匹配，匹配的结果是下一跳和 VLAN Tag。在实现转发表的时候，需要考虑以下的问题：

1. 数据结构：线性查表、Trie
2. 存储位置：LUTRAM、BRAM、SRAM
3. 接口设计：暴露存储、提供插入/删除/查询接口
4. 最大容量：最大承受多大规模的表项

在目前这个阶段可能对这些还没有什么概念，所以不要过度追求大容量和高性能，建议先设计一个基础、能用的模块，然后配合一个比较完善的 testbench，它应该能够测试基本功能，可能的话可以用脚本生成一些测试数据，然后在仿真中测试它的正确性。

在测试的时候，可以通过一些方式进行转发表的预置，先写死几条在里面。对于 XDP RAM，可以用它的参数进行配置内存；通用地，可以写一段逻辑，仅从 reset 变为 0 开始执行，功能就是插入几条固定的表项。

回答以下问题：

1. 为什么要重视 testbench？
2. ThinRouter 上 BRAM 和 SRAM 资源大概都有多大？
3. BRAM 和 SRAM 的延迟谁更低？
4. XDP 都提供了哪几种 RAM？Latency 的配置会有哪些影响？
5. LUTRAM 和 BRAM 的原理不同点在哪？
6. 如何表示一条直连路由？

#### 实现 ARP 表

ARP 表维护的是一个 IP 地址到 MAC 地址的映射关系，比较简单，需要的容量也比较小，简单实现为线性查表或者哈希都可以，可以加上过期的功能。即使比较简单，也要设计好接口，比如查询和插入，写好 testbench，进行足够的测试。

回答以下问题：

1. 如何实现过期删除的功能？
2. IP 地址会有局部性吗？
3. 如何处理满的情况？

### 第三部分：数据通路设计

#### ARP 表自动学习

在 Loopback 基础上，对收到的以太网帧进行解析，判断它的 EtherType （跳过 VLAN），如果是一个 ARP 请求，则提取出字段，然后插入到 ARP 表中。在仿真中观察学习到的 ARP 表项，然后用 ILA 在板子上观察实际学习到的内容。

你可以用 arping 命令来不断发送 ARP 请求，这样有助于调试。如果不想用 ILA，也可以把信号接到 LED 上，但注意如果变换的频率过快，人眼是不能捕捉到 LED 的亮度变化的。

回答以下问题：

1. ARP 的 EtherType 在哪个偏移？
2. OS 一般会在什么情况下发送 ARP 到你的路由器？
3. 如何在 OS 添加一条指向你的路由器的路由？

#### ARP 自动回复

在本实验中，你可以把 ARP 回复实现在硬件中，也可以实现在软件中。实现在硬件中的好处是方便调试，不需要等到软件写好再调，坏处时如果软件需要访问 ARP 表则需要额外的工作。如果要在硬件中写，则需要对 ARP 请求进行判断，如果目标 IP 地址是你的路由器在对应 VLAN 的对应的 IP 地址（自己定，VLAN 通过 VLAN Tag 读出），则构造一个回应然后发出去，而不是原来的 Loopback。回应中，需要注意 MAC 地址和 VLAN
Tag 的填写。

如果实现正确，通过 arping 应该可以得到稳定的低延迟的回复。路由器的 IP 地址和 MAC 地址可以自己定，但建议在标准中用于自由分配的段中进行分配。

回答以下问题：

1. 哪些 ARP 类型不需要回应？
2. 如何在构造的 ARP 回应和交换 MAC 地址的原数据二者之间进行选择？

#### 路由查询和转发

在接受到 IP 包的时候，需要判断是否应该转发，如果应该转发，需要通过查表得知下一跳的信息，再根据下一跳查询到下一跳的 MAC 地址。由于查询过程和接收过程是同时发生的，你需要考虑如何做到高效，尽量保证在需要转发的时候，所需要的信息都已经准备好，可以立即发出去。发出去的时候要进行字段的修改，包括 TTL Checksum，MAC 地址和 VLAN Tag。

具体过程：解析 EtherType 和 Dst IP，判断是否应该转发，如果转发则查询转发表，如果查到了，则得到了下一跳和下一条所在的网口。接着，用下一跳地址（直连路由特殊处理）查询 ARP 表，得到目的 MAC 地址，然后修改 TTL 和 Checksum，再发出。

在仿真中仔细阅读每一步查询的结果和更新后的内容，比对一下各个字段，主要是 MAC 地址、VLAN Tag、TTL 和 Checksum。如果看起来没有问题，可以尝试按照写死的转发表，搭建一个测试网络，用两台电脑互相 ping，抓包查看具体情况。这个时候，ILA 会比较有用，可以看到中间过程每一步查表的结果。另外建议用 Linux 系统进行测试，因为它可以关掉许多不相关的流量，让调试变得比较方便。

回答以下问题：

1. 如果查询转发表，没有找到，应该怎么处理？
2. 如果查询 ARP 表，没有找到，应该怎么处理？
3. 如果 TTL 减到了 0，应该怎么处理？
4. 增量更新 Checksum 的话，会出现哪些特殊情况（提示：RFC 也犯过的错）？

#### 转发正确性测试和压力测试

在上一步能 ping 通的基础上，还需要进一步的正确性测试和压力测试。

正确性测试主要包括：Checksum 各种情况都能正确计算，可以通过减少 ping 的间隔来快速测得；大包也可以正常转发，可以通过 ping 指定 payload 大小或者用 iperf3 测速得到

压力测试：通过 iperf3 进行测速，如果速度出现突然降到零然后不再能 ping 通的情况，一般说明部分逻辑不够鲁棒，或者转发速度跟不上接收速度时，丢包的逻辑不能正确地完整丢包。这种时候，可以通过 ILA 查看内部状态，找到出问题的地方，也可以在 testbench 中增加发包频率，模拟压力测试的情况，然后找到出问题的地方。

回答以下问题：

1. AXI-Stream RX 是没有 tready 信号的，意味着一直会接收数据，怎么实现一个缓冲区？
2. 在实现一个缓冲区的基础上，如何保证丢包的正确性？

### 第四部分：软硬件接口设计

#### 软件接收以太网帧

到这个时候，CPU 基本功能应该已经完成，可以运行代码并往串口打印一些内容。你需要设计一个接口，使得软件可以读取路由器交由 CPU 处理的以太网帧。常见的方案有：

1. 类似串口，寄存器读一次就读一字节，额外添加状态和长度寄存器。
2. 提供一块缓冲区，给定地址和长度，然后轮询。
3. 提供一系列的缓冲区，软件和硬件分别在一个循环列表的头和尾进行操作。

路由器部分需要按照 Dst IP 决定是否需要转给 CPU，常见的就是 RIP 协议（你也可以选择把 RIP 协议放在硬件里实现）。在 CPU 上进行轮询，不断读取收到的数据，通过串口读出来。这一过程中需要把 C 代码编译为 Bare Metal 的汇编，需要配合 linker script 、汇编和若干编译选项进行。

过程中可能会发现 CPU 实现的若干 BUG，或者遇到没有实现的新指令。前者一般可以通过仔细阅读代码找到，后者可以通过修改编译选项解决。

回答以下问题：

1. 为什么需要一段引导汇编？
2. 为什么需要 linker script？

#### 路由器的维护和转发表的更新

在这里，我们区分了路由表和转发表：路由表在软件，转发表在硬件，后者是前者的子集，针对硬件查询而优化。你需要实现一种方法，使得软件可以写（读可选）硬件的转发表，当软件的路由表在更新的时候（比如 RIP 协议的处理过程中），通过这种方法下发到硬件的转发表中。如果实现了读取，就可以通过读出来的数据判断是否正确写入了。如果转发表是基于 RAM 的存储，可以直接给 CPU 提供读取 RAM 的方法，这样就可以比较简单地让 CPU 控制转发表。

如果想要进行无缝的转发表更新，可以实现两份的转发表然后进行原子性的交换；或者在 FSM 的实现上保证不会出现死状态的问题，就可以在牺牲一次转发正确性的情况下解决这个问题。

路由表相比于转发表，主要多了路由协议相关的字段，如 metric。在写入转发表的时候，硬件并不需要这些信息。

#### RIP 协议实现

首先照着路由器 -> CPU 的方法实现 CPU -> 路由器的功能，让软件可以发送任意以太网帧。

然后就可以实现一个基本的 RIP 协议，通过软硬件接口进行 RIP 包的收发和路由表的下发。建议参考软件实验的 README 中相关内容。

## 实验验收基础要求

![Topology](./topology_joint.png)

测试方法（满足部分即可拿到满分，超过满分部分舍去）：

1. 连通性（10%）：PC1-4 两两之间可以互相 `ping` 通
2. 单链接单工：在 PC1 运行 `iperf3 -s`，在 PC2 运行 `iperf3 -c 192.168.5.3`，默认参数运行，带宽不低于 70Mbps （15%），不低于 90Mbps（20%）
3. 双链接单工：在 PC2 运行 `iperf3 -s`，在 PC3 运行 `iperf3 -s`，同时在 PC1 运行 `iperf3 -c 192.168.6.3` 和在 PC4 运行 `iperf3 -c 192.168.7.3`，默认参数运行，带宽之和不低于 100 Mbps（10%），不低于 150Mbps （15%），不低于 180Mbps（20%）
4. 双链接双工：在 PC1-4 运行 `iperf3 -s`，同时在 PC1 运行 `iperf3 -c 192.168.6.3` ，在 PC1 运行 `iperf3 -c 192.168.6.3` 在 PC2 运行 `iperf3 -c 192.168.5.3` 在 PC3 运行 `iperf3 -c 192.168.8.3` 在 PC4 运行 `iperf3 -c 192.168.7.3`，默认参数运行，带宽之和不低于 150 Mbps（20%），不低于 250Mbps （25%），不低于 350Mbps（30%）
5. 单链接单工小包：在 PC2 运行 `iperf3 -s`，在 PC1 运行 `iperf3 -c 192.168.6.3 -u -l 16 -t 5 -b 1G`，在 PC2 计算 0.00-5.00 秒总共的 `(Total Datagrams - Lost) / 5s` ，不低于 1K（5%），不低于 5K（10%），不低于 25K（15%），不低于 50K（20%），不低于 100K（30%）
6. 小规模路由表压力测试（10%）：在 R1 上额外配置 192.168.10.0/24 ~ 192.168.255.0/24 共 246 条新的路由，保证 RIP 协议运行的正确性
7. 中等规模路由表压力测试（15%）：在 R1 R2 R3 R4 上分别配置 10.1.0.0/24 ~ 10.2.255.0/24，10.3.0.0/24 ~ 10.4.255.0/24，10.5.0.0/24 ~ 10.6.255.0/24，10.7.0.0/24 ~ 10.8.255.0/24 共 2048 条新路由，保证 RIP 协议运行和转发功能的正确性
8. 较大规模路由表压力测试（20%）：在 R1 上配置 AS4538 的所有 IPv4 路由（约 5000 条），保证 RIP 协议运行和转发功能的正确性
9. 其他扩展功能：经助教和老师同意可以获得每项不高于 10% 的分数

在 `SetupJoint` 目录下还有用于测试以上各项的脚本 ，执行前需要执行 `./setup.sh` 以配置环境，然后在 tmux 之外运行 `./part[1-8].sh` 以测试各个阶段。此外，`./disable.sh` 会关闭 BIRD 的额外的路由表， `./restart.sh` 会重启 BIRD 。

测试流程：

1. 在 tmux 之外运行 ./setup.sh ，检查 eno1-4 是否分别出现在 R1-4 的 netns，如果不在就在 tmuc 之外再次运行 ./setup.sh 。
2. 在 tmux 之外按顺序运行 ./part{1,2,3,4,5}.sh 进行测试，每个 part 都可以多次运行。
3. 对于路由表的测试，可以运行 ./part{6,7,8}.sh 在 BIRD 中开启对应的路由表，用 ./disable.sh 关掉额外的路由表，用 ./restart.sh 重启 BIRD 。测试过程中，可以通过重启 BIRD 来保证上一阶段的路由表都已经过期。

注意事项：

1. tmux 使用方法网上可查，没有修改配置。
2. Shell 提示符中会显示当前的 netns 。
3. 部分脚本需要在 tmux 外运行。
